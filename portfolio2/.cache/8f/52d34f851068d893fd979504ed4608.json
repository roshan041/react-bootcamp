{"id":"../node_modules/history/history.development.js","dependencies":[{"name":"C:\\Users\\robhagat\\react-bootcamp\\portfolio2\\node_modules\\history\\history.development.js.map","includedInParent":true,"mtime":1645182062147},{"name":"C:\\Users\\robhagat\\react-bootcamp\\portfolio2\\package.json","includedInParent":true,"mtime":1645182324811},{"name":"C:\\Users\\robhagat\\react-bootcamp\\portfolio2\\node_modules\\history\\package.json","includedInParent":true,"mtime":1645182062145}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Action = void 0;\nexports.createBrowserHistory = createBrowserHistory;\nexports.createHashHistory = createHashHistory;\nexports.createMemoryHistory = createMemoryHistory;\nexports.createPath = I;\nexports.parsePath = J;\nvar p,\n    C = p || (exports.Action = p = {});\nexports.Action = p;\nC.Pop = \"POP\";\nC.Push = \"PUSH\";\nC.Replace = \"REPLACE\";\n\nfunction D(e, f) {\n  if (!e) {\n    \"undefined\" !== typeof console && console.warn(f);\n\n    try {\n      throw Error(f);\n    } catch (g) {}\n  }\n}\n\nfunction E(e) {\n  e.preventDefault();\n  e.returnValue = \"\";\n}\n\nfunction F() {\n  let e = [];\n  return {\n    get length() {\n      return e.length;\n    },\n\n    push(f) {\n      e.push(f);\n      return function () {\n        e = e.filter(g => g !== f);\n      };\n    },\n\n    call(f) {\n      e.forEach(g => g && g(f));\n    }\n\n  };\n}\n\nfunction H() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\nfunction I({\n  pathname: e = \"/\",\n  search: f = \"\",\n  hash: g = \"\"\n}) {\n  f && \"?\" !== f && (e += \"?\" === f.charAt(0) ? f : \"?\" + f);\n  g && \"#\" !== g && (e += \"#\" === g.charAt(0) ? g : \"#\" + g);\n  return e;\n}\n\nfunction J(e) {\n  let f = {};\n\n  if (e) {\n    var g = e.indexOf(\"#\");\n    0 <= g && (f.hash = e.substr(g), e = e.substr(0, g));\n    g = e.indexOf(\"?\");\n    0 <= g && (f.search = e.substr(g), e = e.substr(0, g));\n    e && (f.pathname = e);\n  }\n\n  return f;\n}\n\nfunction createBrowserHistory(e = {}) {\n  function f() {\n    let {\n      pathname: b,\n      search: a,\n      hash: d\n    } = q.location,\n        h = k.state || {};\n    return [h.idx, Object.freeze({\n      pathname: b,\n      search: a,\n      hash: d,\n      state: h.usr || null,\n      key: h.key || \"default\"\n    })];\n  }\n\n  function g(b) {\n    return \"string\" === typeof b ? b : I(b);\n  }\n\n  function w(b, a = null) {\n    return Object.freeze(Object.assign(Object.assign({\n      pathname: r.pathname,\n      hash: \"\",\n      search: \"\"\n    }, \"string\" === typeof b ? J(b) : b), {\n      state: a,\n      key: H()\n    }));\n  }\n\n  function z(b) {\n    u = b;\n    [n, r] = f();\n    v.call({\n      action: u,\n      location: r\n    });\n  }\n\n  function A(b, a) {\n    function d() {\n      A(b, a);\n    }\n\n    let h = p.Push,\n        l = w(b, a);\n\n    if (!c.length || (c.call({\n      action: h,\n      location: l,\n      retry: d\n    }), !1)) {\n      let [t, B] = [{\n        usr: l.state,\n        key: l.key,\n        idx: n + 1\n      }, g(l)];\n\n      try {\n        k.pushState(t, \"\", B);\n      } catch (G) {\n        q.location.assign(B);\n      }\n\n      z(h);\n    }\n  }\n\n  function x(b, a) {\n    function d() {\n      x(b, a);\n    }\n\n    let h = p.Replace,\n        l = w(b, a);\n\n    if (!c.length || (c.call({\n      action: h,\n      location: l,\n      retry: d\n    }), !1)) {\n      let [t, B] = [{\n        usr: l.state,\n        key: l.key,\n        idx: n\n      }, g(l)];\n      k.replaceState(t, \"\", B);\n      z(h);\n    }\n  }\n\n  function y(b) {\n    k.go(b);\n  }\n\n  let {\n    window: q = document.defaultView\n  } = e,\n      k = q.history,\n      m = null;\n  q.addEventListener(\"popstate\", function () {\n    if (m) c.call(m), m = null;else {\n      let b = p.Pop,\n          [a, d] = f();\n      if (c.length) {\n        if (null != a) {\n          let h = n - a;\n          h && (m = {\n            action: b,\n            location: d,\n\n            retry() {\n              y(-1 * h);\n            }\n\n          }, y(h));\n        } else D(!1, \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\");\n      } else z(b);\n    }\n  });\n  let u = p.Pop,\n      [n, r] = f(),\n      v = F(),\n      c = F();\n  null == n && (n = 0, k.replaceState(Object.assign(Object.assign({}, k.state), {\n    idx: n\n  }), \"\"));\n  return {\n    get action() {\n      return u;\n    },\n\n    get location() {\n      return r;\n    },\n\n    createHref: g,\n    push: A,\n    replace: x,\n    go: y,\n\n    back() {\n      y(-1);\n    },\n\n    forward() {\n      y(1);\n    },\n\n    listen(b) {\n      return v.push(b);\n    },\n\n    block(b) {\n      let a = c.push(b);\n      1 === c.length && q.addEventListener(\"beforeunload\", E);\n      return function () {\n        a();\n        c.length || q.removeEventListener(\"beforeunload\", E);\n      };\n    }\n\n  };\n}\n\n;\n\nfunction createHashHistory(e = {}) {\n  function f() {\n    let {\n      pathname: a = \"/\",\n      search: d = \"\",\n      hash: h = \"\"\n    } = J(k.location.hash.substr(1)),\n        l = m.state || {};\n    return [l.idx, Object.freeze({\n      pathname: a,\n      search: d,\n      hash: h,\n      state: l.usr || null,\n      key: l.key || \"default\"\n    })];\n  }\n\n  function g() {\n    if (u) b.call(u), u = null;else {\n      let a = p.Pop,\n          [d, h] = f();\n      if (b.length) {\n        if (null != d) {\n          let l = r - d;\n          l && (u = {\n            action: a,\n            location: h,\n\n            retry() {\n              q(-1 * l);\n            }\n\n          }, q(l));\n        } else D(!1, \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\");\n      } else A(a);\n    }\n  }\n\n  function w(a) {\n    var d = document.querySelector(\"base\"),\n        h = \"\";\n    d && d.getAttribute(\"href\") && (d = k.location.href, h = d.indexOf(\"#\"), h = -1 === h ? d : d.slice(0, h));\n    return h + \"#\" + (\"string\" === typeof a ? a : I(a));\n  }\n\n  function z(a, d = null) {\n    return Object.freeze(Object.assign(Object.assign({\n      pathname: v.pathname,\n      hash: \"\",\n      search: \"\"\n    }, \"string\" === typeof a ? J(a) : a), {\n      state: d,\n      key: H()\n    }));\n  }\n\n  function A(a) {\n    n = a;\n    [r, v] = f();\n    c.call({\n      action: n,\n      location: v\n    });\n  }\n\n  function x(a, d) {\n    function h() {\n      x(a, d);\n    }\n\n    let l = p.Push,\n        t = z(a, d);\n    D(\"/\" === t.pathname.charAt(0), `Relative pathnames are not supported in hash history.push(${JSON.stringify(a)})`);\n\n    if (!b.length || (b.call({\n      action: l,\n      location: t,\n      retry: h\n    }), !1)) {\n      let [B, G] = [{\n        usr: t.state,\n        key: t.key,\n        idx: r + 1\n      }, w(t)];\n\n      try {\n        m.pushState(B, \"\", G);\n      } catch (K) {\n        k.location.assign(G);\n      }\n\n      A(l);\n    }\n  }\n\n  function y(a, d) {\n    function h() {\n      y(a, d);\n    }\n\n    let l = p.Replace,\n        t = z(a, d);\n    D(\"/\" === t.pathname.charAt(0), `Relative pathnames are not supported in hash history.replace(${JSON.stringify(a)})`);\n\n    if (!b.length || (b.call({\n      action: l,\n      location: t,\n      retry: h\n    }), !1)) {\n      let [B, G] = [{\n        usr: t.state,\n        key: t.key,\n        idx: r\n      }, w(t)];\n      m.replaceState(B, \"\", G);\n      A(l);\n    }\n  }\n\n  function q(a) {\n    m.go(a);\n  }\n\n  let {\n    window: k = document.defaultView\n  } = e,\n      m = k.history,\n      u = null;\n  k.addEventListener(\"popstate\", g);\n  k.addEventListener(\"hashchange\", () => {\n    let [, a] = f();\n    I(a) !== I(v) && g();\n  });\n  let n = p.Pop,\n      [r, v] = f(),\n      c = F(),\n      b = F();\n  null == r && (r = 0, m.replaceState(Object.assign(Object.assign({}, m.state), {\n    idx: r\n  }), \"\"));\n  return {\n    get action() {\n      return n;\n    },\n\n    get location() {\n      return v;\n    },\n\n    createHref: w,\n    push: x,\n    replace: y,\n    go: q,\n\n    back() {\n      q(-1);\n    },\n\n    forward() {\n      q(1);\n    },\n\n    listen(a) {\n      return c.push(a);\n    },\n\n    block(a) {\n      let d = b.push(a);\n      1 === b.length && k.addEventListener(\"beforeunload\", E);\n      return function () {\n        d();\n        b.length || k.removeEventListener(\"beforeunload\", E);\n      };\n    }\n\n  };\n}\n\n;\n\nfunction createMemoryHistory(e = {}) {\n  function f(c, b = null) {\n    return Object.freeze(Object.assign(Object.assign({\n      pathname: n.pathname,\n      search: \"\",\n      hash: \"\"\n    }, \"string\" === typeof c ? J(c) : c), {\n      state: b,\n      key: H()\n    }));\n  }\n\n  function g(c, b, a) {\n    return !v.length || (v.call({\n      action: c,\n      location: b,\n      retry: a\n    }), !1);\n  }\n\n  function w(c, b) {\n    u = c;\n    n = b;\n    r.call({\n      action: u,\n      location: n\n    });\n  }\n\n  function z(c, b) {\n    let a = p.Push,\n        d = f(c, b);\n    D(\"/\" === n.pathname.charAt(0), `Relative pathnames are not supported in memory history.push(${JSON.stringify(c)})`);\n    g(a, d, function () {\n      z(c, b);\n    }) && (m += 1, k.splice(m, k.length, d), w(a, d));\n  }\n\n  function A(c, b) {\n    let a = p.Replace,\n        d = f(c, b);\n    D(\"/\" === n.pathname.charAt(0), `Relative pathnames are not supported in memory history.replace(${JSON.stringify(c)})`);\n    g(a, d, function () {\n      A(c, b);\n    }) && (k[m] = d, w(a, d));\n  }\n\n  function x(c) {\n    let b = Math.min(Math.max(m + c, 0), k.length - 1),\n        a = p.Pop,\n        d = k[b];\n    g(a, d, function () {\n      x(c);\n    }) && (m = b, w(a, d));\n  }\n\n  let {\n    initialEntries: y = [\"/\"],\n    initialIndex: q\n  } = e,\n      k = y.map(c => {\n    let b = Object.freeze(Object.assign({\n      pathname: \"/\",\n      search: \"\",\n      hash: \"\",\n      state: null,\n      key: H()\n    }, \"string\" === typeof c ? J(c) : c));\n    D(\"/\" === b.pathname.charAt(0), `Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: ${JSON.stringify(c)})`);\n    return b;\n  }),\n      m = Math.min(Math.max(null == q ? k.length - 1 : q, 0), k.length - 1),\n      u = p.Pop,\n      n = k[m],\n      r = F(),\n      v = F();\n  return {\n    get index() {\n      return m;\n    },\n\n    get action() {\n      return u;\n    },\n\n    get location() {\n      return n;\n    },\n\n    createHref: function (c) {\n      return \"string\" === typeof c ? c : I(c);\n    },\n    push: z,\n    replace: A,\n    go: x,\n\n    back() {\n      x(-1);\n    },\n\n    forward() {\n      x(1);\n    },\n\n    listen(c) {\n      return r.push(c);\n    },\n\n    block(c) {\n      return v.push(c);\n    }\n\n  };\n}\n\n;"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"30d2f3194af12b2edd841e65ce3d1352","cacheData":{"env":{}}}